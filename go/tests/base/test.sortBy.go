package base

import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func TestSortBy1() {
	// todo: other argument checks
	exchange := ccxt.NewExchange().(*ccxt.Exchange)
	exchange.DerivedExchange = exchange
	exchange.InitParent(map[string]interface{}{
		"id": "sampleexchange",
	}, map[string]interface{}{}, exchange)
	var arr interface{} = []interface{}{map[string]interface{}{
		"x": 5,
	}, map[string]interface{}{
		"x": 2,
	}, map[string]interface{}{
		"x": 4,
	}, map[string]interface{}{
		"x": 0,
	}, map[string]interface{}{
		"x": 1,
	}, map[string]interface{}{
		"x": 3,
	}}
	var newArray interface{} = exchange.SortBy(arr, "x")
	AssertDeepEqual(exchange, nil, "sortBy", newArray, []interface{}{map[string]interface{}{
		"x": 0,
	}, map[string]interface{}{
		"x": 1,
	}, map[string]interface{}{
		"x": 2,
	}, map[string]interface{}{
		"x": 3,
	}, map[string]interface{}{
		"x": 4,
	}, map[string]interface{}{
		"x": 5,
	}})
	var newArrayDescending interface{} = exchange.SortBy(arr, "x", true)
	AssertDeepEqual(exchange, nil, "sortBy", newArrayDescending, []interface{}{map[string]interface{}{
		"x": 5,
	}, map[string]interface{}{
		"x": 4,
	}, map[string]interface{}{
		"x": 3,
	}, map[string]interface{}{
		"x": 2,
	}, map[string]interface{}{
		"x": 1,
	}, map[string]interface{}{
		"x": 0,
	}})
	var emptyArray interface{} = exchange.SortBy([]interface{}{}, "x")
	AssertDeepEqual(exchange, nil, "sortBy", emptyArray, []interface{}{})
}
func TestSortBy2() {
	exchange := ccxt.NewExchange().(*ccxt.Exchange)
	exchange.DerivedExchange = exchange
	exchange.InitParent(map[string]interface{}{
		"id": "sampleexchange",
	}, map[string]interface{}{}, exchange)
	// sort ascending by key1, then key2 (key1 values are all distinct here)
	var arr interface{} = []interface{}{map[string]interface{}{
		"x": 3,
		"y": 1,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 2,
		"y": 3,
	}, map[string]interface{}{
		"x": 0,
		"y": 4,
	}}
	var sorted interface{} = exchange.SortBy2(arr, "x", "y")
	AssertDeepEqual(exchange, nil, "sortBy2", sorted, []interface{}{map[string]interface{}{
		"x": 0,
		"y": 4,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 2,
		"y": 3,
	}, map[string]interface{}{
		"x": 3,
		"y": 1,
	}})
	// sort descending by key1
	var arr2 interface{} = []interface{}{map[string]interface{}{
		"x": 3,
		"y": 1,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 2,
		"y": 3,
	}, map[string]interface{}{
		"x": 0,
		"y": 4,
	}}
	var sortedDescending interface{} = exchange.SortBy2(arr2, "x", "y", true)
	AssertDeepEqual(exchange, nil, "sortBy2", sortedDescending, []interface{}{map[string]interface{}{
		"x": 3,
		"y": 1,
	}, map[string]interface{}{
		"x": 2,
		"y": 3,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 0,
		"y": 4,
	}})
	// when key1 values are equal, sort by key2 ascending
	var arr3 interface{} = []interface{}{map[string]interface{}{
		"x": 1,
		"y": 5,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 1,
		"y": 9,
	}, map[string]interface{}{
		"x": 1,
		"y": 1,
	}}
	var sortedByKey2 interface{} = exchange.SortBy2(arr3, "x", "y")
	AssertDeepEqual(exchange, nil, "sortBy2", sortedByKey2, []interface{}{map[string]interface{}{
		"x": 1,
		"y": 1,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 1,
		"y": 5,
	}, map[string]interface{}{
		"x": 1,
		"y": 9,
	}})
	// when key1 values are equal, sort by key2 descending
	var arr4 interface{} = []interface{}{map[string]interface{}{
		"x": 1,
		"y": 5,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 1,
		"y": 9,
	}, map[string]interface{}{
		"x": 1,
		"y": 1,
	}}
	var sortedByKey2Descending interface{} = exchange.SortBy2(arr4, "x", "y", true)
	AssertDeepEqual(exchange, nil, "sortBy2", sortedByKey2Descending, []interface{}{map[string]interface{}{
		"x": 1,
		"y": 9,
	}, map[string]interface{}{
		"x": 1,
		"y": 5,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 1,
		"y": 1,
	}})
	// mixed: sort by key1 first, then key2 as tiebreaker
	var arr5 interface{} = []interface{}{map[string]interface{}{
		"x": 2,
		"y": 3,
	}, map[string]interface{}{
		"x": 1,
		"y": 5,
	}, map[string]interface{}{
		"x": 2,
		"y": 1,
	}, map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 2,
		"y": 2,
	}}
	var sortedMixed interface{} = exchange.SortBy2(arr5, "x", "y")
	AssertDeepEqual(exchange, nil, "sortBy2", sortedMixed, []interface{}{map[string]interface{}{
		"x": 1,
		"y": 2,
	}, map[string]interface{}{
		"x": 1,
		"y": 5,
	}, map[string]interface{}{
		"x": 2,
		"y": 1,
	}, map[string]interface{}{
		"x": 2,
		"y": 2,
	}, map[string]interface{}{
		"x": 2,
		"y": 3,
	}})
	// empty array
	var emptyArray interface{} = exchange.SortBy2([]interface{}{}, "x", "y")
	AssertDeepEqual(exchange, nil, "sortBy2", emptyArray, []interface{}{})
}
func TestSortBy() {
	TestSortBy1()
	TestSortBy2()
}
