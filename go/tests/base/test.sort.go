package base

import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func TestSort() {
	exchange := ccxt.NewExchange().(*ccxt.Exchange)
	exchange.DerivedExchange = exchange
	exchange.InitParent(map[string]interface{}{
		"id": "sampleexchange",
	}, map[string]interface{}{}, exchange)
	// empty array
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{}), []interface{}{})
	// single element
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{"a"}), []interface{}{"a"})
	// already sorted (idempotent)
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{"a", "b", "c"}), []interface{}{"a", "b", "c"})
	// duplicates
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{"b", "a", "b", "c"}), []interface{}{"a", "b", "b", "c"})
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{"b", "a", "c", "d"}), []interface{}{"a", "b", "c", "d"})
	// integers (single-digit, safe for cross-language lexicographic/numeric consistency)
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{3, 1, 2}), []interface{}{1, 2, 3})
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{5, 3, 1, 4, 2}), []interface{}{1, 2, 3, 4, 5})
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{0, 3, 1, 2}), []interface{}{0, 1, 2, 3})
	// floats (values chosen so lexicographic order matches numeric order)
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{1.5, 0.5, 2.5}), []interface{}{0.5, 1.5, 2.5})
	AssertDeepEqual(exchange, nil, "sort", exchange.Sort([]interface{}{3.3, 1.1, 2.2}), []interface{}{1.1, 2.2, 3.3})
	// immutability - original array should not be modified
	var original interface{} = []interface{}{"b", "a", "c"}
	exchange.Sort(original)
	AssertDeepEqual(exchange, nil, "sort", original, []interface{}{"b", "a", "c"})
}
